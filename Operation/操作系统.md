# 操作系统

### 概念 

用户和计算机硬件之间的接口

- 提供的功能（用户接口）
  - 命令接口
    - 联机命令接口
      - 用户说一句，系统做一句
    - 脱机命令接口（批处理命令接口）
      - 用户说一堆，系统做一堆 
  - 程序接口（程序接口=系统调用=广义指令）
    - 允许用户通过程序间接使用
  - GUI（图形用户界面）



### 操作系统的特征

- 并发

  - 两个或多个事件在同一时间间隔发生

  > 宏观上是同时发生，微观上是交替发生的，与并行（同一时刻同时发生）有区别

- 共享（资源共享）
  - 互斥共享
    - 一个时间段只允许一个进程访问该资源
  - 同时共享
    - 允许多个进程同时访问

> 并发和共享互为存在条件，为操作系统两个最基本的特征

- 虚拟
  - 空分复用技术（虚拟存储技术）
  - 时分复用技术（虚拟处理器）
- 异步
  - 由于资源有限，进程的执行不是一贯到底的 

### 操作系统的发展与分类

手工操作阶段

1. 纸带机
2. 输入计算机
3. 输出纸带

> 问题：用户独占全机，人机速度矛盾导致资源利用效率较低



##### 批处理阶段——单道批处理系统

引入脱机输入输出技术（磁带），使用监督系统（操作系统的雏形）控制作业输入输出

作业从纸带由外围机读入速度更快的磁带，通过磁带实现输入输出计算机

> 缓解人机速度不匹配的矛盾

##### 批处理阶段——多道批处理系统

每次向内存中输入多道程序

> 操作系统诞生，并引入中断技术；用户响应时间长，无人机交互



### 分时操作系统

解决了多道批处理系统无法人机的问题，分时操作系统以时间片为单位，轮流服务，用户可以使用终端与计算机进行交互



### 实时操作系统

解决了分时操作系统无法优先响应一些紧急任务的缺点，一些紧急任务不需要排队

- 硬实时系统
- 软实时系统



### 运行机制与体系结构

CPU两种处理状态

- 用户态（目态）
  - CPU只能执行非特权指令
- 核心态（管态）
  - 特权指令和非特权指令

两种程序

- 内核程序（核心态）
- 应用程序（用户态）

操作系统内核

- 时钟管理
  - 实现计时功能
- 中断处理
  - 负责实现中断机制
- 原语
  - 这种程序的运行是具有原子性的——其运行不能被中断
- 对系统资源进行管理的功能
  - 进程管理
  - 存储器管理
  - 设备管理

> 依据不同的操作系统，对资源管理的部分不一定属于内核功能 



操作系统的体系

- 大内核
  - 将操作系统的主要功能模块都作为系统内核，运行在核心态
  - 性能高
  - 内核代码庞大，难以维护
- 微内核
  - 只保留最基本的功能 
  - 需要在核心态和用户态之间切换，性能低



### 中断机制

只要发生中断就意味着操作系统的介入

- 当发生中断时，CPU进入核心态
- 中断发生时，当前进程暂停运行，并由CPU内核对中断进行处理

> 用户态到核心态的切换，是通过中断实现的，并且中断是实现的唯一途径
>
> 核心态到用户态的转换是通过执行一条特权指令

##### 中断的分类

- 内中断（异常）
  - 自愿中断——指令中断
  - 强迫中断
    - 硬件故障
    - 软件中断
- 外中断
  - 外设请求
  - 人工干预



### 系统调用

系统调用相关处理涉及到对系统资源的管理，这些功能需要执行一些特权指令，相关系统调用处理需要在核心态下进行

##### 系统调用的实现过程

1. 传递系统调用参数
2. 执行陷入指令（用户态）
3. 执行系统调用相应服务程序（核心态）
4. 返回用户程序

> 陷入指令是在用户态执行的，执行陷入指令立即引发内中断，从而CPU进入核心态
>
> 发出系统调用请求是在用户态，对系统调用相关处理是在核心态
>
> 陷入指令是唯一一个只能在用户态执行，而不可以在核心态执行的命令



### 进程（动态）

创建一个进程实质上是创建 `PCB` 

> `PCB` 是进程存在的唯一标志

##### 进程实体（静态）

- 程序段
- 数据段
- `PCB`

##### 进程的组成

- 进程描述信息

  - 进程标识符 `PID`
  - 用户标识符 `UID`

- 进程控制和管理信息

  - 进程当前状态
  - 进程优先级

- 资源分配清单

  - 程序段指针
  - 数据段指针

- 处理机相关信息

  - 各种寄存器的值

  - > 当进程需要切换时，需要把当前进程的信息保存下来

> `PCB` 操作系统相关



##### 进程的组织方式

- 链接方式——指针
  - 执行指针
  - 就绪队列指针
  - 阻塞队列指针
- 索引方式——索引表

##### 进程的特征

- 动态性
  - 程序的依次执行过程
- 并发性
  - 进程实体可以并发执行
- 独立性
  - 进程是可以独立的运行，独立的获取得资源，独立接受调度的基本单位
- 异步性
  - 各自按给自独立的，不可预知的速度向前推进
- 结构性
  - 每个进程都会配置一个 `PCB`



##### 进程的状态

- 运行态
- 就绪态
- 阻塞态
- 创建态
  - 进程正在被创建，操作系统为进程分配资源，初始化 `PCB`
- 终止态
  - 进程从系统中撤销，操作系统会回收进程拥有的资源，撤销 `PCB`

> 注：不能有阻塞态直接转变为运行态，也不能直接由就绪态转变为阻塞态（进入阻塞态是进程主动请求的）



##### 进程控制

原语：原语的执行特点是执行期间不允许中断；原语只运行在核心态

- 进程创建
- 进程终止
- 进程阻塞
- 进程唤醒
- 进程切换

> 阻塞和唤醒要成对出现



### 进程通信

为了保证安全，一个进程不能直接访问其他进程的地址空间

- 共享存储
  - 基于数据结构的共享（低级通信方式）
  - 基于存储区的共享（高级通信方式）
    - 两个进程对共享空间的访问必须是互斥的（P、V操作）
- 消息传递
  - 进程中数据的交换是以格式化消息为单位（消息头+消息体）
  - 直接通信
    - 直接挂到消息缓冲队列
  - 间接通信
    - 先发送到中间实体

- 管道通信
  - 管道在内存中开辟的固定大小的缓冲区
  - 各个进程对管道的访问是互斥的

> 管道只能实现半双工通信，一段时间内只能实现单向传输，如果想要实现双向需要使用两个管道
>
> 管道写满时，写进程阻塞，空时读进程阻塞
>
> 没写满，不允许读
>
> 数据一旦被读，就将被抛弃，因此读进程最多有一个，否则数据可能出错		



### 线程 

- 线程可以理解为轻量级的进程
- 线程是一个CPU的基本执行单位也是程序执行流的最小单位 
- 每个线程都有自己的 ID 和线程控制块（TCB）
- 线程几乎不拥有系统资源
- 同一进程不同线程共享资源，并共享内存地址——线程之间的通信不需要系统的干预



##### 线程的实现方式

- 用户级线程
  - 由应用程序负责
- 内核级线程
  - 内核级线程才是处理机分配的单位 	



##### 多线程模型

- 多对一

  - 映射到一个内核级线程
  - 用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理系统开销小
  - 当一个用户级线程发生阻塞时，整个进程都会被阻塞，并发度不高。多线程不可以在多核处理机上运行

- 一对一

  - 一个用户级线程对应一个内核级线程
  - 一个线程被阻塞后其他进程还可以执行，并发能力强
  - 一个用户进程占用多个内核级进程，线程的切换到核心态，开销大

- 多对多

  

### 调度

- 高级调度（作业调度）
  - 内存与外存之间的调度
  - 无 》》创建态 》》 就绪态

- 中级调度（内存调度）
  - 引入虚拟内存技术之后，可将暂时不能运行的进程调至外存等待（挂起），`PSB` 任然是存在于内存之中的（挂起队列）
  - 挂起态 》》 就绪态

- 低级调度（进程调度）
  - 按某种方法在就绪队列中选取一个进程，将处理机分配给它
  - 就绪态 》》运行态

> 挂起与阻塞的区别：挂起之后是存在于系统外存，阻塞态是存在于内存



##### 进程调度的时机

- 当前运行的进程主动放弃处理机
  - 进程正常终止
  - 进程运行过程中发生异常
  - 主动请求阻塞
- 当前进程被动放弃处理机
  - 时间片使用完
  - 出现其他更加紧急或优先级更高的进程
- 不能进行进程调度与切换的情况
  - 处理中断
  - 进程在操作系统内核程序临界区中（进程在普通临界区中是允许调度和切换的）
  - 进行原语操作



##### 进程调度方式

- 非剥夺调度方式（非抢占式）
  - 只允许进程主动放弃处理机	
  - 实现简单，系统开销较小（适合早期批处理系统）
- 剥夺调度方式（抢占式）



##### 进程的切换与进程调度

- 狭义的进程调度
  - 选中一个要运行的进程（刚才被停止的进程，或是其他进程——进程切换）
- 进程切换
  - 进程让出处理机，让其他进程使用的情况
- 广义的进程调度包含两个步骤
- 进程切换的过程
  - 原来运行的进程数据进行保存
  - 新进程数据的恢复

> 进程的切换是有代价的，频繁的进程切换，会使得整个操作系统的运行效率降低



##### CPU利用率

##### 系统吞吐量

- 单位时间内完成的作业

##### 周转时间

##### 带权周转时间



### 调度服务

##### 先来先服务（FCFS）

- 非抢占式算法
- 对长作业有利，对短作业不利
- 不会导致饥饿

##### 短作业优先（SJF）

- 非抢占式算法
  - 抢占式版本——最短剩余时间优先算法
- 对短作业有利，进程的时间是由用户和程序提供的，不一定真实，所以不一定能够做到正真意义上的短作业优先
- 会产生饥饿现象

##### 高响应比运行（HRRN）

- 非抢占式
- 综合考虑长作业和短作业
- 不会导致饥饿

##### 时间片轮转（RR）

- 抢占式（由时钟中断）
- 公平：响应快，适用于分时操作系统
- 不会导致饥饿

> 如果时间片太大，导致每个进程都可以在一个时间片里面完成，那么时间片轮转算法会退化为先来先服务调度算法：会增大进程时间
>
> 如果时间片太小，导致进程频繁切换，系统将会花费大量时间处理进程切换

##### 优先级调度

- 抢占式/非抢占式

- 优先级区分进程的紧急和重要程度，适用于分时操作系统。

- 源源不断的高优先级进程可能导致饥饿

  

> 补充：就绪队列可能不止一个，可以按照不同的优先级来组织
>
> 根据优先级是否可以发生动态改变：静态优先级：优先级不会发生改变；动态优先级：创建进程时有一个初值，之后根据情况动态的改变优先级	

- 优先级的设置
  - 系统进程的优先级高于用户进程
  - 前台进程的优先级要高于后台进程
  - 操作系统更加偏好于I/O型进程（计算型进程——CPU繁忙型进程）
    - I/O繁忙型进程优先运行，越可能让I/O设备和CPU并行的工作，可以使得系统资源的利用率和系统吞吐量得到提升
  - 等待时间长提升优先级，运行时间长减少优先级，I/O频繁的进程适当提升优先级

##### 多级反馈队列

设置多级就绪队列，优先级由高到低，时间片由小到大；新进程到达先进入第一级队列，按`FCFS`原则等待被分配的时间片，如果时间片用完还未结束，则该进程进入下一级队列的末尾	

- 抢占式
- 对各类进程相对公平（FCFS），每个进程到达之后都可以很快的响应（RR），短进程只需要较少的时间就能完成（SPF），不必评估运行时间，可以灵活的调整对于各类进程的偏好
- 会导致饥饿



### 进程同步（直接制约）

- 进程同步是讨论如何解决进程异步的问题
  - 为了完成某个任务而建立的一个或多个进程，因需要而在某些位置上协调工作次序而产生的制约关系

> 进程具有异步性的特征——各并发执行的进程以各自独立的，不可预知的速度向前推进

### 进程互斥（间接制约）

- 并发执行的进程不可避免的需要并发实行需要共享资源

互斥共享方式

- 一个时间段只允许一个进程访问该资源

> 一个时间段只允许一个进程使用的资源——临界资源

##### 实现进程的互斥（逻辑分类）

- 进入区
  - 检查当前是否能访问临界资源，如果可以进入（设置正在访问临界资源标志——上锁）
- 临界区（临界段）
  - 访问临界区资源的代码
- 退出区
  - 解除上锁
- 剩余区
  - 其他

##### 原则

- 空闲让进
  - 临界区空闲可以允许一个请求进入临界区的进程立即进入临界区
- 忙则等待
  - 已有进程进入临界区，其他进程想要进入临界区必须等待
- 有限等待
  - 保证不饥饿
- 让权等待
  - 进程不能进入临界区时，立即释放处理机	



### 进程互斥的软件实现法

- 单标志法
  - 两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程，每个进程进入临界区的权限只能被另一个权限赋予
  - 违背了 ”空闲让进“ 原则
- 双标志先检查
  - 设置 `boolean` 数组，用来标记各个进程想进入临界区的意愿（先检查，后上锁）
  - 违反 “忙则等待” 的原则
- 双标志后检查
  - 可能两个进程都无法进入临界区
- `Peterson` 算法



### 进程互斥的硬件实现

- 中断屏蔽法
  - 使用开关中断指令，实现（和原语实现的思想相类似，不允许被中断）
    - 不适用于多处理机，只适用于操作系统内核程序，不适合用户进程（开关中断指令只能在内核态使用）
- `TestAndSet`(TS/TSL指令)
  - 用硬件实现的，执行过程中不允许被中断
    - 与软件实现比起来，使用硬件的方式使 上锁和解锁 变成了原子操作
    - 实现简单，无需使用像软件一样严格的逻辑检查；适用于多处理机
- `Swap`指令（XCHG指令）
  - 使用硬件实现，交换值
  - 逻辑上同`TEL`



### 信号量机制

用户进程可以使用操作系统提供的一对原语来对信号量进行操作，从而实现进程的同步和互斥

>  信号量是一种变量(整型 / 记录型变量)，表示系统中某种资源的数量
>
> 使用系统提供的一对原语 `wait(S)` 和 `signal(S)`——先加减再判断（阻塞 / 唤醒）

- 整型信号量
  - 与普通变量相比较它对信号量的操作只有三种
    - 初始化
    - P操作
    - V操作
  - 不满足让权等待的原则
  
- ###### 记录型信号量

  - `S.value` 表示某种资源数，`S.L` 指向等待该资源的队列
  - P 操作先执行 `S.value--`，之后可能需要执行 `block` 原语
  - V 操作先执行 `S.value++`，之后可能执行 `wakeup` 原语

> 检查和上锁一部合成，避免并发和异步导致的问题





### 信号量机制实现进程互斥

- 划定临界区（同一时间内只允许一个资源访问）
- 设置互斥信号量 `mutex`，初始值为 1

> 对不同的临界资源要设置不同的互斥信号量，`P,V`操作必须成对的出现

##### 信号量机制实现进程同步

1. 分析什么地方需要实现“同步关系”，必须保证一前一后实现两个操作
2. 设置同步信号量 `S`， 初始化值为0
3. 在前操作执行执行之后执行 `V` 操作
4. 在后操作执行之前执行 `P` 操作

```bash
P1(){
Code1;
Code2;
V(S);
COde3;
}
P2(){
P(S);
Code4;
Code5;
}
# 代码2执行在代码4之前
```



# 问题

### 生产者消费者问题：

系统中有一组生产者进程和消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从中取出一个产品使用 （产品——数据）	

使用`PV`操作来实现生产者，消费者进程的功能

信号量机制来实现互斥和同步的功能

作题分析

- 关系分析，找出题目中描述的各个进程，并分析它们之间的同步、互斥的关系
- 确定各个进程的流程和`PV`操作大概的顺序

> 生产者和消费者共享一个初始为空，大小为n的缓冲区
>
> 只有缓冲区没满时，生产者才把产品放入缓冲区，否则必须等待（==同步==）
>
> 只有缓冲区不满时，消费者才能从中取出产品
>
> 缓冲区是临界资源，各进程必须互斥的访问（==互斥==）



> 在多生产者多消费者问题中，如果临界区资源超过`1`，必须设置互斥信号量保证互斥的访问缓冲区