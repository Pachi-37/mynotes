### 类之间的关系

- 依赖

> 尽量让类之间的耦合度最小

- 聚合

> 包含关系

- 继承

> 特殊与一般的关系

### 对象

对象与对象变量之间存在着一个重要的区别

对象变量可以引用对象，需要经过初始化才能应用方法

- 初始化对象变量
  - 使用新构造的对象初始化
  - 引用已经存在的对象
  - 可以使用`null`，表明对象变量未引用对象，此时使用对象方法会产生运行错误



##### 隐式参数与显示参数

- 隐式参数
  - 方法调用的目标或接收者（`this`）
- 显示参数
  - 方法括号内的参数



### 封装优点

- 使用独立的访问控制器来访问，设置实例域为只读域，防止受到外界的破坏
- 更改器方法可以执行错误检查
- 设置
  - 一 私有的数据域
  - 一 公有的域访问器方法
  - 一个公有的域更改器方法
- 注意
  - 如果对象是可变的，就会破坏封装性，如果需要返回一个引用应该先对其克隆，返回可变数据域的拷贝



### 私有方法

- 大部分情况下方法都被设计成公有的，但是在一些特殊的情况下也将他们设计为私有的
  - 将计算机代码分解为若干个独立的辅助方法，辅助方法不应该成为辅助接口
  - 该方法实现要借助特殊的协议或是方法在访问使存在着特殊的顺序关系



### `fianl`

将对象定义为 `fianl` 实例域，构建对象必须初始化

##### 应用

- 大多用于基于 `private` 的域
- 不可变的类
  - `final` 的引用指向不会发生改变，但是对象可以改变



### 静态域和静态方法

##### 静态域

- 将域定义为 `static`，每个类中只有一个这样的域，它属于类不属于任何独立的对象

##### 静态初始模块

- 对类的静态域进行初始化的代码比较复杂，使用静态的初始化块——将代码放在一个块中，并标记关键字 static

##### 静态常量

- 通过对象进行访问，并且每个对象都拥有自己的一份拷贝	

##### 静态方法

- 不能向对象实施的操作方法，没有隐式的参数

- 静态方法无法操作实例域（无法操作对象），但是可以访问自身类的静态域

- 使用情况

  - 不需要访问对象状态，其所需参数都是通过显式参数提供
  - 只需要访问类的静态域
  - 工厂方法
    - 定义一个创建对象的接口，将实例化的步骤推迟到子类实现
    - 使用
      - 无法命名构造器 
      - 使用构造器无法改变对象的类型

- `main`

  - 一般情况下一个类可以包含一个 `main` 方法，实现单元测试
    - Java程序最小的功能单元是方法，因此，对Java程序进行单元测试就是针对单个Java方法的测试

  

### 方法参数

- 将参数传递给方法
  - 按值调用——接收调用者提供的值
  - 按引用调用——接收调用者提供的变量地址
- 注意
  - 方法不能修改一个基本数据类型的参数（即数值型或布尔型）
  - 方法可以改变一个对象参数的状态
  - 方法不能让对象参数引用一个新的对象。



### 对象构造

##### 重载

- 一个类含有多个构造器

> 如果一个类不含构造器，会默认提供一个无参构造器，如果不含有无参构造器该类不合法

- 一些方法拥有相同的名字，不同的参数

> 因为重载的使用，因此完整的描述一个方法，需要指出方法名以及参数类型（签名），返回值不属于签名

##### 默认域初始化

> 如果构造器中没有给域赋予初值，那么会被自动的赋予默认值

##### 显示域初始化

##### 参数名

- 在编写较小的构造器时，在参数命名上可能会产生错误（单个字符命名），但是这样命名会产生一些问题只有阅读代码才知道参数的含义
  - 可以在参数名前面加一个`a`作为前缀
  - 使用 `this.` 方式 访问实例域

##### 调用另一个构造器

- 使用 `this.` 可以调用其他的构造器
- 调用构造器必须写在第一行

##### 初始化模块（可选用）

- 为了避免循环定义， 不要读取在后面初始化的域





## 包

借助包可以跟加方便的组织自己的代码，将同名代码库分开

> Java中推荐使用公司的英特网域名逆序命名包

##### 类的导入

- 一个类可以使用所属包中的所有类，以及其他包中的公共类
- 访问另一个包中的公共类
  - 在每个类名 之前添加完整的包名
  - `import` 导入特定的类或者包

> `import java.util.*` 自动扩展到指定的导入列表中
>
> 注：使用 `*` 只能导入一个包，一般情况下不需要写	全需要导入的类名，但当类产生冲突时需要使用特定的 `import` 语句导入具体的包名



##### 静态导入

###### `import` 还可以导入静态方法和静态域

- 使用 System 类的静态方法和静态域，而不必加类名前缀
  - `import static java.lang.System.*`
- 导入特定的方法和域
  - `import static java.lang.System.out;`	



##### 将类放入一个包当中

- 如果没有在源文件中放置 `package` 语句会被放入默认包里面，想要 将类放入一个包，将包的名字放在源文件开头



### 类的路径

- 类的路径必须域包名相匹配，另外可以识别 `jar`  包
  - 可以将 `package` 名称对应的路径使用 `jar` 命令归档成 `jar` 包

##### 设置类的路径

- 使用 `-classpath` `-cp` 指定类路径

```Java
java -classpath [path]
```

- 环境变量完成此种操作（依赖于 `Shell`）

> 警告：将 `class path` 设置为永久不变的值；绕开类路径，将所有文件存储在 `jar/lib/ext`



### 文档注释

`javadoc` 由源文件生成一个 `HTML` 文档

##### 注释的插入

`javadoc` 从以下几个特性中抽取信息‘

- 包
- 公有类于接口
- 公有的和受保护的构造器及方法
- 公有的和受保护的域



- 每个 `/** . . . */` 文档注释在标记之后紧跟着自由格式文本
  - 标记由 `@` 开
  - 自由格式文本的第一句应该是一个概要性的句子
  - 可以使用 `HTML` 修饰符，但是不能使用 `<hl>` 或 `<hr>`
  - 键入等宽代码 `{@code}`



##### 类注释

- 类注释必须放在 `import` 之后，类定义之前



##### 方法注释

- 放在方法之前
- 通用标记
- 其他标记
  - `@param` 变量描述
    - 一个方法的所有 `@param` 标记必须放在一起
  - `@return` 描述
  - `©throws` 类描述



##### 域注释

- 对公共域（静态常量）



##### 通用注释

- `@author` 姓名
- `@version` 文本
  - 对当前版本的描述
- `@sinee` 文本
  - 引人特性的版本描述
- `@deprecated` 文本
  - 不再推荐
- `®see` 引用
  - 超链接



##### 包与概述注释

- 要想产生包注释，就需要在每一个包目录中添加一个单独的文件
  - 提供一个以 `package.html` 命名的 `HTML` 文件。在标记 `<body>`之间的所有文本都会被抽取出来
  - 提供一个以 `package-info.java` 命名的 `Java` 文件。 这个文件必须包含一个初始的以 `/**`和 `*/ `界定的 `Javadoc` 注释， 跟随在一个包语句之后



##### 注释的抽取

```Java
javadoc -d docDirectory nameOfPackage
// -d docDirectory 如果被省略，注释将会被提取当前目录，会引起混乱
```

